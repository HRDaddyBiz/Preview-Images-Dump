<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HR Daddyâ„¢ Image Processor - Multi-Profile Edition</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=Montserrat:wght@400;500;600&display=swap');

body {
    font-family: 'Montserrat', sans-serif;
    background: #1a1a1a;
    color: #fff;
    padding: 20px;
    margin: 0;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
}

h1 {
    font-family: 'Cormorant Garamond', serif;
    font-weight: 700;
    text-align: center;
    margin-bottom: 40px;
    font-size: 48px;
}

.upload-section {
    background: #2a2a2a;
    padding: 30px;
    border-radius: 10px;
    margin-bottom: 30px;
    text-align: center;
    border: 2px dashed #3a3a3a;
    transition: all 0.3s ease;
}

.upload-section.highlight {
    border-color: #48bb78;
    background-color: rgba(72, 187, 120, 0.1);
}

input[type="file"] {
    display: none;
}

.upload-btn {
    background: #4a5568;
    color: white;
    padding: 15px 40px;
    border-radius: 5px;
    cursor: pointer;
    display: inline-block;
    transition: background 0.3s;
    font-weight: 500;
    font-size: 16px;
}

.upload-btn:hover {
    background: #5a6578;
}

.preview-section {
    display: grid;
    gap: 20px;
    margin-top: 30px;
}

.image-item {
    background: #2a2a2a;
    padding: 15px;
    border-radius: 10px;
    border: 1px solid #3a3a3a;
    display: grid;
    grid-template-columns: 120px 1fr auto;
    gap: 15px;
    align-items: center;
}

.image-thumbnail {
    width: 120px;
    height: 80px;
    object-fit: contain;
    background: #1a1a1a;
    border-radius: 5px;
    padding: 5px;
}

.file-info {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.file-name {
    font-weight: 500;
    color: #fff;
    font-size: 16px;
}

.file-details {
    font-size: 13px;
    color: #a0aec0;
}

.download-individual {
    background: #4a5568;
    color: white;
    padding: 8px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s;
    font-size: 14px;
    white-space: nowrap;
}

.download-individual:hover {
    background: #5a6578;
}

.download-all-section {
    background: #1a1a1a;
    padding: 20px;
    border-radius: 10px;
    margin-top: 20px;
    text-align: center;
    border: 2px solid #48bb78;
}

.download-all-btn {
    background: #48bb78;
    color: white;
    padding: 15px 40px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 18px;
    font-weight: 600;
    transition: background 0.3s;
}

.download-all-btn:hover {
    background: #38a169;
}

.file-count {
    color: #a0aec0;
    margin-bottom: 15px;
    font-size: 16px;
}

.favicon-grid-compact {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
    gap: 10px;
    margin: 15px 0;
}

.favicon-preview {
    text-align: center;
    background: #1a1a1a;
    padding: 5px;
    border-radius: 5px;
}

.favicon-preview canvas {
    max-width: 100%;
    height: auto;
}

.image-container {
    position: relative;
    display: inline-block;
    width: 100%;
}

canvas {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 0 auto;
    border: 1px solid #3a3a3a;
}

.download-btn {
    background: #48bb78;
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 15px;
    width: 100%;
    transition: background 0.3s;
    font-weight: 500;
    font-size: 16px;
}

.download-btn:hover {
    background: #38a169;
}

.filename {
    margin-top: 10px;
    color: #a0aec0;
    font-size: 14px;
}

.loading {
    text-align: center;
    padding: 40px;
    color: #a0aec0;
}

.loading::after {
    content: '';
    display: inline-block;
    width: 20px;
    height: 20px;
    margin-left: 10px;
    border: 3px solid #4a5568;
    border-top-color: #48bb78;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.footer-note {
    color: #a0aec0;
    font-size: 12px;
    margin-top: 8px;
    text-align: center;
}

.error-message {
    background: #e53e3e;
    color: white;
    padding: 15px;
    border-radius: 5px;
    margin-bottom: 20px;
    font-weight: 500;
}

.download-btn:disabled {
    background: #4a5568;
    cursor: not-allowed;
    opacity: 0.6;
}

/* Favicon preview styling */
canvas {
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-crisp-edges;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
}
</style>
</head>
<body>
<div class="container">
    <h1>HR Daddyâ„¢ Image Processor</h1>
    <p style="text-align: center; color: #a0aec0; margin-top: -20px;">Maximum quality optimization for all export formats</p>
    
    <div class="upload-section" id="uploadSection">
        <label for="fileInput" class="upload-btn">Select Images to Process</label>
        <input type="file" id="fileInput" multiple accept="image/png,image/jpeg,image/jpg">
        
        <div style="margin-top: 20px;">
            <label for="outputProfile" style="display: block; margin-bottom: 8px; color: #a0aec0; font-weight: 500;">Select Output Profile:</label>
            <select id="outputProfile" style="width: 300px; padding: 10px; background: #1a1a1a; color: #fff; border: 1px solid #4a5568; border-radius: 5px; font-size: 16px;">
                <option value="favicon">Favicon (All Sizes)</option>
                <option value="preview-png" selected>Preview Image (PNG)</option>
                <option value="preview-jpg">Preview Image (JPG)</option>
                <option value="website-png">Website PNG</option>
                <option value="website-jpg">Website JPG</option>
                <option value="high-res">High-Res Archive</option>
            </select>
        </div>
        
        <p style="margin-top: 15px; color: #a0aec0;">Images will be processed according to selected output profile</p>
        <p style="margin-top: 5px; color: #48bb78; font-size: 14px;">Drag & drop images here or click to select</p>
        <p style="margin-top: 5px; color: #e53e3e; font-size: 14px;">Max file size: 10MB per image â€¢ Formats: PNG, JPG</p>
    </div>
    
    <div id="previewSection" class="preview-section"></div>
    
    <div id="clearSection" style="display: none; text-align: center; margin-top: 30px;">
        <button id="clearAllBtn" style="background: #e53e3e; color: white; padding: 12px 30px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: 500;">
            Clear All Images
        </button>
    </div>
</div>

<script>
'use strict';

// Constants
const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
const SUPPORTED_FORMATS = ['image/png', 'image/jpeg', 'image/jpg'];
const MIN_FONT_SIZE = 24;
const WATERMARK_BASE_SCALE = 0.03; // 3% of width
const CIRCLE_RADIUS_RATIO = 0.9;
const BANNER_HEIGHT_RATIO = 0.055;
const MAX_CONCURRENT_PROCESSING = 5;

// Store all processed files for download
let processedFiles = [];
let processingQueue = [];
let isProcessing = false;
let activeProcessing = 0;

// Global error handler
window.addEventListener('error', (event) => {
    console.error('Global error caught:', event.error);
    const errorMsg = document.createElement('div');
    errorMsg.className = 'error-message';
    errorMsg.innerHTML = `<strong>An error occurred:</strong> ${event.error?.message || 'Unknown error'}. Please refresh and try again.`;
    
    const previewSection = document.getElementById('previewSection');
    if (previewSection && !previewSection.querySelector('.error-message')) {
        previewSection.insertBefore(errorMsg, previewSection.firstChild);
    }
    
    // Auto-dismiss after 5 seconds
    setTimeout(() => errorMsg.remove(), 5000);
    event.preventDefault();
});

// Initialize with DOM ready check
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}

function initializeApp() {
    try {
        setupDragAndDrop();
        setupEventListeners();
        console.log('HR Daddyâ„¢ Image Processor initialized successfully');
    } catch (error) {
        console.error('Initialization error:', error);
    }
}

function setupDragAndDrop() {
    const uploadSection = document.getElementById('uploadSection');
    if (!uploadSection) return;
    
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        uploadSection.addEventListener(eventName, preventDefaults, false);
    });
    
    ['dragenter', 'dragover'].forEach(eventName => {
        uploadSection.addEventListener(eventName, highlight, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
        uploadSection.addEventListener(eventName, unhighlight, false);
    });
    
    uploadSection.addEventListener('drop', handleDrop, false);
}

function setupEventListeners() {
    const fileInput = document.getElementById('fileInput');
    const clearBtn = document.getElementById('clearAllBtn');
    const outputProfile = document.getElementById('outputProfile');
    
    if (fileInput) {
        fileInput.addEventListener('change', handleFiles);
    }
    
    if (clearBtn) {
        clearBtn.addEventListener('click', clearAll);
    }
    
    if (outputProfile) {
        outputProfile.addEventListener('change', handleProfileChange);
        outputProfile.addEventListener('focus', storeOldValue);
    }
}

function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
}

function highlight(e) {
    const uploadSection = document.getElementById('uploadSection');
    if (uploadSection) {
        uploadSection.classList.add('highlight');
    }
}

function unhighlight(e) {
    const uploadSection = document.getElementById('uploadSection');
    if (uploadSection) {
        uploadSection.classList.remove('highlight');
    }
}

function handleDrop(e) {
    try {
        const dt = e.dataTransfer;
        const files = dt.files;
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            fileInput.files = files;
            handleFiles({ target: { files } });
        }
    } catch (error) {
        console.error('Drop handling error:', error);
    }
}

function handleProfileChange(event) {
    if (processedFiles.length > 0) {
        const proceed = confirm('Changing the profile will clear current results. Continue?');
        if (proceed) {
            clearAll();
        } else {
            event.target.value = event.target.oldvalue || 'preview-png';
        }
    }
}

function storeOldValue(event) {
    event.target.oldvalue = event.target.value;
}

function clearAll() {
    try {
        // Clear UI
        const previewSection = document.getElementById('previewSection');
        const fileInput = document.getElementById('fileInput');
        const clearSection = document.getElementById('clearSection');
        const uploadSection = document.getElementById('uploadSection');
        
        if (previewSection) previewSection.innerHTML = '';
        if (fileInput) fileInput.value = '';
        if (clearSection) clearSection.style.display = 'none';
        if (uploadSection) uploadSection.classList.remove('highlight');
        
        // Clear memory
        processedFiles.forEach(file => {
            if (file.blob) {
                try {
                    // Attempt to free blob memory
                    file.blob = null;
                } catch (e) {
                    // Silent fail
                }
            }
        });
        
        // Reset arrays
        processedFiles = [];
        processingQueue = [];
        isProcessing = false;
        activeProcessing = 0;
        
        // Remove download section
        const downloadAllSection = document.getElementById('downloadAllSection');
        if (downloadAllSection) {
            downloadAllSection.remove();
        }
        
        // Force garbage collection hint
        if (window.gc) {
            window.gc();
        }
    } catch (error) {
        console.error('Clear all error:', error);
    }
}

async function handleFiles(e) {
    try {
        const files = e.target.files;
        const previewSection = document.getElementById('previewSection');
        
        if (!files || files.length === 0) return;
        
        // Prevent processing if already processing
        if (isProcessing) {
            showNotification('Please wait for current processing to complete', 'warning');
            return;
        }
        
        isProcessing = true;
        
        // Reset state
        processedFiles = [];
        processingQueue = [];
        
        // Remove existing download section
        const existingDownloadAll = document.getElementById('downloadAllSection');
        if (existingDownloadAll) {
            existingDownloadAll.remove();
        }
        
        if (previewSection) {
            previewSection.innerHTML = '<div class="loading">Processing images with selected profile...</div>';
        }
        
        // Show clear button
        const clearSection = document.getElementById('clearSection');
        if (clearSection) {
            clearSection.style.display = 'block';
        }
        
        // Validate files
        const validFiles = [];
        const errors = [];
        
        Array.from(files).forEach(file => {
            // Size validation
            if (file.size > MAX_FILE_SIZE) {
                errors.push(`${file.name} exceeds ${MAX_FILE_SIZE / 1024 / 1024}MB limit`);
                return;
            }
            
            // Type validation
            if (!SUPPORTED_FORMATS.includes(file.type)) {
                errors.push(`${file.name} is not a PNG or JPG file`);
                return;
            }
            
            validFiles.push(file);
        });
        
        // Use requestAnimationFrame for smooth UI update
        requestAnimationFrame(() => {
            if (previewSection) {
                previewSection.innerHTML = '';
            }
            
            // Show errors if any
            if (errors.length > 0) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.innerHTML = '<strong>Validation Errors:</strong><br>' + errors.join('<br>');
                if (previewSection) {
                    previewSection.appendChild(errorDiv);
                }
                
                // Auto-dismiss errors after 5 seconds
                setTimeout(() => errorDiv.remove(), 5000);
            }
            
            // Queue processing for performance
            if (validFiles.length > 0) {
                processingQueue = validFiles;
                processNextInQueue();
            } else {
                isProcessing = false;
            }
        });
        
    } catch (error) {
        console.error('File handling error:', error);
        isProcessing = false;
        showNotification('Error processing files. Please try again.', 'error');
    }
}

function processNextInQueue() {
    if (processingQueue.length === 0 || activeProcessing >= MAX_CONCURRENT_PROCESSING) {
        if (processingQueue.length === 0 && activeProcessing === 0) {
            isProcessing = false;
            updateDownloadAllButton();
        }
        return;
    }
    
    const file = processingQueue.shift();
    activeProcessing++;
    
    // Use requestAnimationFrame for smooth processing
    requestAnimationFrame(() => {
        processImage(file, processedFiles.length).finally(() => {
            activeProcessing--;
            processNextInQueue();
        });
    });
    
    // Continue processing queue
    if (processingQueue.length > 0 && activeProcessing < MAX_CONCURRENT_PROCESSING) {
        setTimeout(() => processNextInQueue(), 50);
    }
}

function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 20px;
        background: ${type === 'error' ? '#e53e3e' : type === 'warning' ? '#ed8936' : '#48bb78'};
        color: white;
        border-radius: 5px;
        z-index: 1000;
        animation: slideIn 0.3s ease;
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

// Profile dropdown change handler
document.getElementById('outputProfile').addEventListener('change', (event) => {
    if (processedFiles.length > 0) {
        const proceed = confirm('Changing the profile will clear current results. Continue?');
        if (proceed) {
            document.getElementById('clearAllBtn').click();
        } else {
            // Restore previous selection
            event.target.value = event.target.oldvalue || 'preview-png';
        }
    }
});

// Store old value on focus
document.getElementById('outputProfile').addEventListener('focus', (event) => {
    event.target.oldvalue = event.target.value;
});
    // Clear UI
    document.getElementById('previewSection').innerHTML = '';
    document.getElementById('fileInput').value = '';
    document.getElementById('clearSection').style.display = 'none';
    
    // Reset drag-drop visual state
    uploadSection.classList.remove('highlight');
    
    // Clear processed files array
    processedFiles = [];
    processingQueue = [];
    isProcessing = false;
    
    // Remove download all section if exists
    const downloadAllSection = document.getElementById('downloadAllSection');
    if (downloadAllSection) {
        downloadAllSection.remove();
    }
});

// Update download all button
function updateDownloadAllButton() {
    // Remove existing download all section
    let downloadAllSection = document.getElementById('downloadAllSection');
    if (!downloadAllSection) {
        downloadAllSection = document.createElement('div');
        downloadAllSection.id = 'downloadAllSection';
        downloadAllSection.className = 'download-all-section';
        document.getElementById('previewSection').after(downloadAllSection);
    }
    
    downloadAllSection.innerHTML = `
        <div class="file-count">${processedFiles.length} files ready for download</div>
        <button class="download-all-btn" onclick="downloadAllFiles()">
            ðŸ“¦ Download All Files
        </button>
    `;
}

// Download all files function
async function downloadAllFiles() {
    if (processedFiles.length === 0) {
        alert('No files to download');
        return;
    }
    
    const downloadBtn = document.querySelector('.download-all-btn');
    const originalText = downloadBtn.textContent;
    downloadBtn.textContent = 'â³ Preparing downloads...';
    downloadBtn.disabled = true;
    
    try {
        // Filter out any null blobs
        const validFiles = processedFiles.filter(file => file.blob);
        
        if (validFiles.length === 0) {
            throw new Error('No valid files to download');
        }
        
        // For browsers that support multiple downloads
        if (validFiles.length <= 10) {
            // Download files individually with slight delay
            for (let i = 0; i < validFiles.length; i++) {
                const file = validFiles[i];
                try {
                    await new Promise(resolve => setTimeout(resolve, i * 200));
                    const url = URL.createObjectURL(file.blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = file.filename;
                    a.click();
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                } catch (error) {
                    console.error(`Failed to download ${file.filename}:`, error);
                }
            }
        } else {
            // For many files, warn user and download with longer delays
            const proceed = confirm(`This will download ${validFiles.length} files. Your browser may ask for permission to download multiple files. Continue?`);
            
            if (proceed) {
                for (let i = 0; i < validFiles.length; i++) {
                    const file = validFiles[i];
                    try {
                        await new Promise(resolve => setTimeout(resolve, i * 300));
                        const url = URL.createObjectURL(file.blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = file.filename;
                        a.click();
                        setTimeout(() => URL.revokeObjectURL(url), 100);
                    } catch (error) {
                        console.error(`Failed to download ${file.filename}:`, error);
                    }
                }
            }
        }
        
        // Show success feedback
        downloadBtn.textContent = 'âœ“ Downloads started!';
        setTimeout(() => {
            downloadBtn.textContent = originalText;
            downloadBtn.disabled = false;
        }, 2000);
        
    } catch (error) {
        console.error('Download all failed:', error);
        alert('Download failed. Please try downloading files individually.');
        downloadBtn.textContent = originalText;
        downloadBtn.disabled = false;
    }
}

function processImage(file, index) {
    const reader = new FileReader();
    const outputProfile = document.getElementById('outputProfile').value;
    
    reader.onerror = function() {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'image-item error-message';
        errorDiv.innerHTML = `
            <strong>Failed to read: ${file.name}</strong><br>
            <span style="font-size: 14px;">The file may be corrupted or in an unsupported format. Please try another image.</span>
        `;
        document.getElementById('previewSection').appendChild(errorDiv);
    };
    
    reader.onload = function(e) {
        const img = new Image();
        
        img.onerror = function() {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'image-item error-message';
            errorDiv.innerHTML = `
                <strong>Failed to process: ${file.name}</strong><br>
                <span style="font-size: 14px;">The image file appears to be corrupted or uses an unsupported color format. Please try converting it to standard RGB PNG/JPG format.</span>
            `;
            document.getElementById('previewSection').appendChild(errorDiv);
        };
        
        img.onload = function() {
            // Get profile settings
            const settings = getProfileSettings(outputProfile, img.width);
            
            // Handle multi-size favicon generation
            if (settings.multiSize && settings.sizes) {
                processFaviconMultiSize(img, file, index, settings);
                return;
            }
            
            // Regular single-size processing
            processSingleImage(img, file, index, settings);
        };
        img.src = e.target.result;
    };
    
    reader.readAsDataURL(file);
}

function getProfileSettings(profile, originalWidth) {
    const profiles = {
        'favicon': {
            width: 512,
            format: 'image/png',
            quality: 1.0,  // Maximum quality for crisp icons
            watermark: false,
            suffix: '-favicon.png',
            profileName: 'Favicon (All Sizes)',
            watermarkScale: 0,
            multiSize: true,
            sizes: [16, 32, 48, 64, 128, 180, 192, 256, 512]  // Added 256px
        },
        'preview-png': {
            width: 1600,
            format: 'image/png',
            quality: 0.95,  // Increased for best quality
            watermark: true,
            suffix: '-preview.png',
            profileName: 'Preview Image (PNG)',
            watermarkScale: 1
        },
        'preview-jpg': {
            width: 1600,
            format: 'image/jpeg',
            quality: 0.88,  // Optimized for quality/size balance
            watermark: true,
            suffix: '-preview.jpg',
            profileName: 'Preview Image (JPG)',
            watermarkScale: 1
        },
        'website-png': {
            width: 1200,
            format: 'image/png',
            quality: 0.85,  // Reduced for better file size
            watermark: true,
            suffix: '-web.png',
            profileName: 'Website PNG',
            watermarkScale: 0.75
        },
        'website-jpg': {
            width: 1200,
            format: 'image/jpeg',
            quality: 0.82,  // Slightly reduced for web optimization
            watermark: true,
            suffix: '-web.jpg',
            profileName: 'Website JPG',
            watermarkScale: 0.75
        },
        'high-res': {
            width: Math.min(Math.max(originalWidth, 1600), 2400),
            format: 'image/png',
            quality: 0.98,  // Near-lossless for archival
            watermark: true,
            suffix: '-archived.png',
            profileName: 'High-Res Archive',
            watermarkScale: 1.2
        }
    };
    
    return profiles[profile] || profiles['preview-png'];
}

function processSingleImage(img, file, index, settings) {
    // Create canvas with profile-specific dimensions
    const targetWidth = settings.width;
    const aspectRatio = img.height / img.width;
    const targetHeight = Math.round(targetWidth * aspectRatio);
    
    const canvas = document.createElement('canvas');
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    
    const ctx = canvas.getContext('2d');
    
    // Set high-quality rendering
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    // Draw the image
    ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
    
    // Apply watermark if required
    if (settings.watermark) {
        applyEnhancedWatermark(ctx, canvas.width, canvas.height, settings.watermarkScale);
    }
    
    // Create download link
    const imageItem = document.createElement('div');
    imageItem.className = 'image-item';
    
    const imageContainer = document.createElement('div');
    imageContainer.className = 'image-container';
    imageContainer.appendChild(canvas);
    
    // Generate filename with proper suffix
    const baseName = file.name.replace(/\.[^/.]+$/, '')
        .replace(/â„¢/g, '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
    const filename = baseName + settings.suffix;
    
    const downloadBtn = document.createElement('button');
    downloadBtn.className = 'download-btn';
    downloadBtn.textContent = 'Download Processed Image';
    downloadBtn.onclick = () => {
        canvas.toBlob(blob => {
            // Display file size
            const sizeKB = (blob.size / 1024).toFixed(1);
            const sizeDisplay = document.getElementById(`size-${index}`);
            if (sizeDisplay) {
                sizeDisplay.textContent = `Output size: ${sizeKB} KB`;
            }
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }, settings.format, settings.quality);
    };
    
    // Profile info display
    const profileInfo = document.createElement('div');
    profileInfo.style.cssText = 'margin-top: 10px; padding: 10px; background: #1a1a1a; border-radius: 5px; font-size: 14px;';
    profileInfo.innerHTML = `
        <div><strong>Profile:</strong> ${settings.profileName}</div>
        <div><strong>Resolution:</strong> ${canvas.width} Ã— ${canvas.height}px</div>
        <div><strong>Format:</strong> ${settings.format.toUpperCase()}</div>
        <div><strong>Compression:</strong> ${Math.round(settings.quality * 100)}%</div>
        <div id="size-${index}" style="color: #48bb78;"><strong>Output size:</strong> Click download to calculate</div>
    `;
    
    const filenameDiv = document.createElement('div');
    filenameDiv.className = 'filename';
    filenameDiv.textContent = `Output: ${filename}`;
    
    const footerNote = document.createElement('div');
    footerNote.className = 'footer-note';
    footerNote.textContent = settings.watermark ? 
        'Optimized for Stripe & HRDaddy.biz | Do not crop or reuse without written permission.' : 
        'Processed by HR Daddyâ„¢ Image Processor';
    
    imageItem.appendChild(imageContainer);
    imageItem.appendChild(profileInfo);
    imageItem.appendChild(downloadBtn);
    imageItem.appendChild(filenameDiv);
    imageItem.appendChild(footerNote);
    
    document.getElementById('previewSection').appendChild(imageItem);
}

function processFaviconMultiSize(img, file, index, settings) {
    const imageItem = document.createElement('div');
    imageItem.className = 'image-item';
    
    const baseName = file.name.replace(/\.[^/.]+$/, '')
        .replace(/â„¢/g, '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '');
    
    // Detect background color
    const bgColor = detectBackgroundColor(img);
    
    // Create container for all favicon sizes
    const faviconGrid = document.createElement('div');
    faviconGrid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; margin-bottom: 15px;';
    
    const canvases = [];
    
    // Generate each favicon size
    settings.sizes.forEach(size => {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        if (ctx.colorSpace) {
            ctx.colorSpace = 'srgb';
        }
        
        // Fill with background color
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, size, size);
        
        // Create circular clipping path
        ctx.save();
        ctx.beginPath();
        ctx.arc(size / 2, size / 2, size / 2 * CIRCLE_RADIUS_RATIO, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();
        
        // Draw image scaled to square within circle
        const sourceSize = Math.min(img.width, img.height);
        const sx = (img.width - sourceSize) / 2;
        const sy = (img.height - sourceSize) / 2;
        
        ctx.drawImage(img, sx, sy, sourceSize, sourceSize, 0, 0, size, size);
        ctx.restore();
        
        // Create display container
        const sizeContainer = document.createElement('div');
        sizeContainer.style.cssText = 'text-align: center; background: #1a1a1a; padding: 10px; border-radius: 5px;';
        
        const canvasWrapper = document.createElement('div');
        canvasWrapper.style.cssText = 'background: #fff; padding: 5px; display: inline-block; margin-bottom: 5px;';
        canvasWrapper.appendChild(canvas);
        
        const sizeLabel = document.createElement('div');
        sizeLabel.style.cssText = 'font-size: 12px; color: #a0aec0;';
        sizeLabel.textContent = `${size}Ã—${size}`;
        
        sizeContainer.appendChild(canvasWrapper);
        sizeContainer.appendChild(sizeLabel);
        faviconGrid.appendChild(sizeContainer);
        
        canvases.push({ canvas, size });
    });
    
    // Profile info
    const profileInfo = document.createElement('div');
    profileInfo.style.cssText = 'margin-bottom: 15px; padding: 10px; background: #1a1a1a; border-radius: 5px; font-size: 14px;';
    profileInfo.innerHTML = `
        <div><strong>Profile:</strong> ${settings.profileName} (Multi-Resolution)</div>
        <div><strong>Sizes:</strong> ${settings.sizes.join(', ')}px</div>
        <div><strong>Format:</strong> PNG with circular mask</div>
        <div><strong>Quality:</strong> Maximum (100%)</div>
        <div><strong>Background Color:</strong> <span style="display: inline-block; width: 20px; height: 20px; background: ${bgColor}; vertical-align: middle; border: 1px solid #666;"></span> ${bgColor}</div>
        <div><strong>Usage:</strong> 16-32px for browser tabs, 48-128px for desktop, 180-192px for mobile, 256px for Windows</div>
    `;
    
    // Download buttons container
    const downloadContainer = document.createElement('div');
    downloadContainer.style.cssText = 'display: grid; gap: 10px;';
    
    // Toggle for square vs circle
    const toggleContainer = document.createElement('div');
    toggleContainer.style.cssText = 'margin-bottom: 15px; display: flex; align-items: center; gap: 10px;';
    
    const circleToggle = document.createElement('input');
    circleToggle.type = 'checkbox';
    circleToggle.id = `circle-toggle-${index}`;
    circleToggle.checked = true;
    circleToggle.style.cssText = 'width: 20px; height: 20px;';
    
    const toggleLabel = document.createElement('label');
    toggleLabel.htmlFor = `circle-toggle-${index}`;
    toggleLabel.style.cssText = 'color: #a0aec0; cursor: pointer;';
    toggleLabel.textContent = 'Use circular background (recommended for modern browsers)';
    
    toggleContainer.appendChild(circleToggle);
    toggleContainer.appendChild(toggleLabel);
    
    // Regenerate favicons when toggle changes
    circleToggle.addEventListener('change', () => {
        regenerateFavicons(img, canvases, bgColor, circleToggle.checked);
    });
    
    // Individual download buttons
    canvases.forEach(({ canvas, size }) => {
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'download-btn';
        downloadBtn.style.cssText = 'padding: 8px 16px;';
        downloadBtn.textContent = `Download ${size}Ã—${size} PNG`;
        downloadBtn.onclick = () => {
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${baseName}-favicon-${size}x${size}.png`;
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/png', 1.0);  // Maximum quality for favicons
        };
        downloadContainer.appendChild(downloadBtn);
    });
    
    // Download all button
    const downloadAllBtn = document.createElement('button');
    downloadAllBtn.className = 'download-btn';
    downloadAllBtn.style.cssText = 'background: #e53e3e; margin-top: 10px;';
    downloadAllBtn.textContent = 'Download All Favicon Sizes (ZIP)';
    downloadAllBtn.onclick = async () => {
        alert('To create a proper .ico file with all sizes, download each size and use an online ICO converter like favicon.io or realfavicongenerator.net');
    };
    
    const footerNote = document.createElement('div');
    footerNote.className = 'footer-note';
    footerNote.innerHTML = 'Generated by HR Daddyâ„¢ Image Processor<br>Circular background ensures consistent appearance across all platforms';
    
    imageItem.appendChild(profileInfo);
    imageItem.appendChild(toggleContainer);
    imageItem.appendChild(faviconGrid);
    imageItem.appendChild(downloadContainer);
    imageItem.appendChild(downloadAllBtn);
    imageItem.appendChild(footerNote);
    
    document.getElementById('previewSection').appendChild(imageItem);
}

function detectBackgroundColor(img) {
    try {
        // Create temporary canvas to sample colors
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = Math.min(img.width, 100); // Limit size for performance
        tempCanvas.height = Math.min(img.height, 100);
        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
        
        if (!tempCtx) {
            return 'rgb(240, 240, 240)'; // Default gray if context fails
        }
        
        // Scale down for faster processing
        tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
        
        // Sample colors from corners
        const samples = [];
        const positions = [
            [0, 0], // top-left
            [tempCanvas.width - 1, 0], // top-right
            [0, tempCanvas.height - 1], // bottom-left
            [tempCanvas.width - 1, tempCanvas.height - 1] // bottom-right
        ];
        
        let hasTransparency = false;
        
        positions.forEach(([x, y]) => {
            try {
                const pixel = tempCtx.getImageData(x, y, 1, 1).data;
                if (pixel[3] < 255) hasTransparency = true;
                samples.push({
                    r: pixel[0],
                    g: pixel[1],
                    b: pixel[2],
                    a: pixel[3]
                });
            } catch (e) {
                // If getImageData fails, use default color
                samples.push({ r: 240, g: 240, b: 240, a: 255 });
            }
        });
        
        // If image has transparency, return a neutral gray
        if (hasTransparency) {
            return 'rgb(240, 240, 240)';
        }
        
        // Calculate average color from corners
        const avg = samples.reduce((acc, color) => {
            acc.r += color.r;
            acc.g += color.g;
            acc.b += color.b;
            return acc;
        }, { r: 0, g: 0, b: 0 });
        
        const count = samples.length;
        const finalColor = {
            r: Math.round(avg.r / count),
            g: Math.round(avg.g / count),
            b: Math.round(avg.b / count)
        };
        
        // Clean up
        tempCanvas.width = 1;
        tempCanvas.height = 1;
        
        return `rgb(${finalColor.r}, ${finalColor.g}, ${finalColor.b})`;
    } catch (error) {
        console.error('Error detecting background color:', error);
        return 'rgb(240, 240, 240)'; // Default gray on any error
    }
}

function regenerateFavicons(img, canvases, bgColor, useCircle) {
    try {
        canvases.forEach(({ canvas, size }) => {
            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            
            // Maintain quality settings
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            if (ctx.colorSpace) {
                ctx.colorSpace = 'srgb';
            }
            
            ctx.clearRect(0, 0, size, size);
            
            // Fill with background color
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, size, size);
            
            if (useCircle) {
                // Create circular clipping path
                ctx.save();
                ctx.beginPath();
                ctx.arc(size / 2, size / 2, size / 2 * CIRCLE_RADIUS_RATIO, 0, Math.PI * 2);
                ctx.closePath();
                ctx.clip();
            }
            
            // Draw image scaled to square
            const sourceSize = Math.min(img.width, img.height);
            const sx = (img.width - sourceSize) / 2;
            const sy = (img.height - sourceSize) / 2;
            
            ctx.drawImage(img, sx, sy, sourceSize, sourceSize, 0, 0, size, size);
            
            if (useCircle) {
                ctx.restore();
            }
        });
    } catch (error) {
        console.error('Favicon regeneration error:', error);
    }
}

function applyEnhancedWatermark(ctx, width, height, scale = 1) {
    // Skip watermark for scale 0 (favicon)
    if (scale === 0) return;
    
    // Save context state
    ctx.save();
    
    // Calculate dynamic font sizes based on canvas width and scale
    const baseFontSize = Math.round(width * WATERMARK_BASE_SCALE);
    
    const diagonalSize = Math.max(Math.round(baseFontSize * 1.75 * scale), MIN_FONT_SIZE * 1.5);
    const cornerSize = Math.max(Math.round(baseFontSize * 1.5 * scale), MIN_FONT_SIZE);
    const copyrightSize = Math.max(Math.round(baseFontSize * 0.7 * scale), 16);
    
    // Determine best watermark placement based on image dimensions
    const isSquarish = Math.abs(width - height) < 200;
    const usesDiagonal = isSquarish || height > width * 0.8;
    
    // Set enhanced shadow system
    ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
    ctx.shadowBlur = 8 * scale;
    ctx.shadowOffsetX = 3 * scale;
    ctx.shadowOffsetY = 3 * scale;
    
    if (usesDiagonal) {
        // Diagonal watermark for square-ish images
        const mainText = 'HR Daddyâ„¢ â€” Protected Creative Content';
        ctx.font = `bold ${diagonalSize}px Cormorant Garamond, serif`;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.75 * Math.min(scale, 1)})`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // First diagonal watermark
        ctx.save();
        ctx.translate(width / 2, height / 2);
        ctx.rotate(-Math.PI / 6); // 30 degree angle
        ctx.fillText(mainText, 0, 0);
        ctx.restore();
        
        // Additional watermarks for larger scale or wide images
        if (width >= 1200 && scale >= 1) {
            ctx.save();
            ctx.translate(width / 2, height / 2);
            ctx.rotate(-Math.PI / 6);
            const offset = height * 0.15;
            ctx.fillText(mainText, 0, -offset);
            ctx.fillText(mainText, 0, offset);
            ctx.restore();
        }
    } else {
        // Bottom-right corner for landscape images
        const mainText = 'HR Daddyâ„¢ â€” Protected Creative Content';
        ctx.font = `bold ${cornerSize}px Cormorant Garamond, serif`;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.75 * Math.min(scale, 1)})`;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        
        // Position main watermark
        const margin = width * 0.025; // 2.5% margin
        ctx.fillText(mainText, width - margin, height - (margin * 4));
        
        // Add second instance if wide enough and scale allows
        if (width >= 1200 && scale >= 1) {
            ctx.textAlign = 'left';
            ctx.fillText(mainText, margin, height - (margin * 4));
        }
    }
    
    // Enhanced copyright banner - more prominent
    ctx.save();
    
    // Banner height scales with canvas
    const bannerHeight = Math.max(Math.round(height * BANNER_HEIGHT_RATIO * scale), 40);
    
    // Create semi-transparent background bar with gradient
    const gradient = ctx.createLinearGradient(0, height - bannerHeight, 0, height);
    gradient.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, height - bannerHeight, width, bannerHeight);
    
    // Enhanced shadow for copyright text
    ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
    ctx.shadowBlur = 5 * scale;
    ctx.shadowOffsetX = 2 * scale;
    ctx.shadowOffsetY = 2 * scale;
    
    const copyrightText = 'Â© HR Daddy LLC â€” All rights reserved. Unauthorized use or distribution is prohibited.';
    ctx.font = `bold ${copyrightSize}px Montserrat, sans-serif`;
    ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * Math.min(scale, 1)})`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(copyrightText, width / 2, height - (bannerHeight / 2));
    
    ctx.restore();
    
    // Restore context
    ctx.restore();
}
</script>
</body>
</html>